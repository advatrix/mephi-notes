# Лабы
- 5 обязательных (язык С)
- 6 для особо умных

сервер samos.dozen.mephi.ru 

# Литература
- робачевский немнюгин стесик Операционная система UNIX (всё для экзамена, там всё что абв говорит)
- таненбаум Современные операционные системы
- Ефанов Мельников никитин Алгоритмы и структуры ядра Linux

# История
### ibm 360

виртуальная память решает проблему когда в нескольких программах задается один и тот же диапазон адресов -- иначе они не смогут выполняться в режиме мультипрограммирования + проге надо будет ждать когда именно её кусок памяти будет загружен, это дает возможность не привязывать прогу к физическим реальным адресам. в процессе работы проги одни и те же виртуальные адреса для каждой команды преобразуются в реальные на аппаратном уровне -- небольшое замедление большой профит

разграничение доступа тк многотерминальный режим и много пользователей

появляются процессоры которые на аппаратном уровне поддерживают базовые функции ОС (например виртуальная память)

первые серии программно совместимых машин: неудобно каждый раз выпускать новую архитектуру -- новая архитектура должна поддерживать все старые команды чтобы старые проги запускались
- мейнфреймы ibm360 / в сср единые серии ЕС
- мини pdp11 (в ссср см3 см4 см420, система малых эвм)

80 годы
- допустили ошибку: раз комп персональный, можно ниче не поддерживать, ни защищенный режим, ни мультипрограммирование, ни разные процессы, ни виртуальной памяти
- но потом они поняли какие они дурачки

os/2 зачем-то юзала 3 кольца защиты вместо двух (всего максимум 4)

minix может работать даже на 8086 потому что там программно реализован защищенный режим а обычный линукс работает только с аппаратным защищенным режимом поэтому он не запускается на 8086


# Unix

в юниксе два типа объектов
- процесс
- файл
	- устройства
и всё можно отнести к одному  из этих типов
любое действие в системе выполняется от имени какого-то процесса

пользователей в системе нет
- пользователь это атрибут процесса
- шелл процесс от нашего имени выполняет действия в системе
- пользователи нужны чтобы для процесса при доступе к объекту была проверка прав

в отличие от винды (где несколько букв) юниксовая система имеет один корень

каталоги
- etc shadow специфика линукса
	- изначально там хранился хеш паролей
	- внутри системы юзаются только уиды а не имена пользователей
- etc passwd дб доступен на чтение всем пользователям чтобы маппить уиды на имена
	- следовательно хеши тоже видны - а значит пароли можно подбирать
	- поэтому хеши убрали из passwd и перенесли в shadow
	- если во втором поле написано x значит хеш паролей перенесен в shadow
- tmp
	- если оперативки достаточно то он весь монтируется туда
- стандартные утилиты так как они не меняются перекочевали в /usr
- в самом начале ФС /usr не смонтирована поэтому в bin sbin lib помещают только проги нужные на самом начальном этапе
	- всё остальное в usr
	- при старте срабатывает команда mount которая находится в bin
		- для обычного пользователя только заранее заданные фс
		- для админа любую какую хочет
	- заголовки для си не меняются и в usr/include
- var/log - системный журнал
	- быстро растет и файлы иногда должны архивироваться и/или удаляться
- var/tmp - временные файлы которые нельзя удалять
	- аварийная копия вима при краше
- var - временные файлы которые не надо удалять системе и при перезагрузке
	- spool - напр задания печати, крон сценарии

процессы
- прикладные - юзер проги 
- системные - что не висит в фоне
- демоны
	- с ними общаться только сигналами
	- `*d*`
	- в качестве родителя процесс init

атрибуты процесса
- pid
- терминал - то устройство с которого процесс работает если запрашивать stdin stdout и стандартный протокол

init pid = 1

на картинке в слайде все кроме первого и последнего это спец пользователи чтобы исполнять за них команды

стандартные пользователи - пользователи которые нужны для работы демонов
- bin - владелец всех программ в каталоге bin и тд

основные подсистемы ядра
- файловая
- управления процессами
	- распределение ресурсов
		- процессорное время
		- память
- ввода вывода
	- любая работа с файлом тк он на диске
	- буферизация нужна потому что система не работает с байтами а с блоками
		- при записи - по мере заполнения буфера или по закрытии файла
	- драйвер принимает команды от ядра (открыть/закрыть/etc) и преобразует их в специфические команды устройства

загрузчик размещает в ОП файл программы при запуске -- образ процесса
- режим ядра при системных вызовах
- структура proc не входит в образ процесса потому что на некоторых стадиях существования процесса образа еще нет или уже нет

граф состояний процесса ***(надо знать на экзе на тройку)***
- пример для одноядерного процессора
- в каждый момент ремени в состоянии 1-2 может находиться только один процесс. при этом не мб такого что один в 1 другой в 2 - среди этих двух состояний мб только 1 процесс
- при системном вызове проц переключается в режим ядра а после выполнения переходит в режим задачи и так периодически
	- периодически приходит прерывание от таймера
	- каждый раз при переключении ядро-задача вызывается планировщик, который принимает решение дать ли процессу перейти в режим задач или переключить контекст
		- если переключение контекста то процесс переходит в режим готов запуску, контекст сохраняется
		- меняется с другим процессом
		- внутри процесса это незаметно
		- в режиме готов запуску очередь из процессов
	- если прервать проц в произвольный момент то системные таблицы могут быть в некорректном состоянии
	- если в режиме ядра надо ждать
		- процесс переходит в режим сна
		- планировщик берет другой процесс из тех кто готов к запуску
		- когда ресурс становится доступен приходит прерывание
			- обработчик прерывания переведет соответствующий процесс из сна в режим готов к запуску
- если процесс выполняет форк создается точная копия процесса с одинаковым почти кодом
	- выход из форка происходит уже из двух процессов
	- дочерний попадает в готов к запуску, тк родительский процесс выполнялся - у него нет недоступных ресурсов, а дочерний его точная копия
- процесс завершается либо сам (систеный вызов exit)
	- либо по сигналу - тогда он становится зомби
	- ресурсы высвобождаются и удаляется образ
	- остаётся только запись о нём
		- там есть код возврата (статус завершения процесса)
		- например если родительский процесс ждал wait то он его получил и после этого запись зомби из таблицы процессов будет удалена
		- пока родительский процесс не сделает wait зомби не умрет 

АП - адресное пространство

приоритеты повышаются по мере пребывания в очереди

прерывание от таймера
- пересчет приоритетов процессов
