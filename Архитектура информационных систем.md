# 0. Введение

- для ВС главное производительность, они про вычисления с примлемой погрешностью
- для ИС -- тк они для больших объемов информации - главное объём внешней памяти + надежность памяти, инфа должна долго сохраняться + быстрый доступ к ней
	- большое внимание юзер интерфейсу, который ориентируется на предметную область ИС
	- средста управления инфой - часто субд - чтобы информацию извлекать быстро

### Категории ИС
- когда инфы много там есть скрытые закономерности, для этого используют dss (decision support systems) - например дата майнинг
- ecm (enterprise content management) системы - юзают не бд или хранилища а более продвинутые штуки (файловые системы или чет другое)
- OLTP


# 1. Архитектура клиент-сервер

### Организация клиент-сервер

- централизованная архитектура
	- у каждого юзера есть приложение на котором одновременно и клиент и сервер
	- на клиентских машинах дублируется код
	- надо исключить ситуации когда два разных приложения модифицируют одни данные - проблемы с синхронизацией
- архитектура с диспетчеризацией
	- для параллельной работы с данными появляется диспетчер, который балансирует нагрузку запросов от юзеров между субд


### Структура приложения

- разные ис отличаются прикладным компонентом, только он в полной мере зависит от предметной области
- компонент доступа это субд и sql

## Модели технологии клиент сервер
### File Server

Первые ИС разрабатывались с технологией File Server. На сервере хранится вся информация, а на клиенте вся логика. Клиент получает файлы с сервера и уже сам реализует логику.

### Remote Data Access
- на сервере субд
- все вычисления на клиенте
- главная проблема толстый клиент - вся обработка на его стороне => повышенные требования к клиентской машине
- зато освобождают сервер от несвойственных ему задач

### Data Base Server
- прикладной компонент в виде процедур выполняющих соответствующие операции
- клиент вызывает нужные процедуры на сервере
- вызов процедур = события
- чтобы сервер выполнял процедуры они должны быть написаны на языке сервера то есть на sql => они реализованы в виде хранимых процедур а эт сложно

-----

bce 
- boundary - взаимодействие с другими участниками системы
- entity - данные приближены к тому что дб представлено
- на слайде не хранилище а *система* хранения данных

## Транзакции

**Транзакция** - некоторая единица работы которая переводит бд из одного согласованного состояния в другое согласованное (кот удовл всем требованиям предметной области) состояние
- внутри транзакции согл состояние мб нарушено
- окончание транзакции
	- commit - фиксировать изменения в бд
	- rollback - откатить
- acid

параллелизм
- потеря результатов обновления
	- победит та транзакция которая последняя сделает коммит
- чтение грязных данных
	- первая транзакция будет с неправильными данными
- неповторяющееся чтение
	- разные результаты при последовательных чтениях у первой транзакции
- фантомы
	- вторая транзакция вставляет запись которая удовлеторяет условию тета
	- а потом первая транзакция увидит ещё одну запись - фантом
- проблема в том что транзакции читают данные не дожидаясь фиксации другой транзакции
	- чтобы этого не было используется механизм блокировок
	- S - Shared - на данные, когда транзакция их читает. S блокировки от нескольких транзакций сосуществуют вместе
	- X - Exclusive - блокировка на изменение - не может сосуществовать ни с кем
	- если транзакция не может поставить блокировку она переводится в состояние ожидания
		- транзакция может *свою* S блокировку заменить на Х (select for update)
			- если есть другая транзакция которая поставила на данные S блокировку это нельзя
		- в другую сторону не работает
	- блокировки ставятся при выполнении предложений sql а снимаются по окончании транзакции по commit / rollback
	- субд помнит не только какая блокировка поставлена но и кем
- дедлок (устранение потери результатов обновления)
	- есть таймаут по истечении которого транзакция откатывается и все блокировки снимаются
	- такие ситуации надо избегать
- устранение потерянных изменений
- решение проблемы фантомов
	- объектом блокировки становятся не записи, а индексы
	- чтобы вторая транзакция не могла вставить новую запись, удовлетворяющую данному условию
	- механизм блокирования записей эту проблему не устраняет
	- если блокировка ставится на индекс и делается попытка вставить новую запись, то изменяется соответствующее значение индекса (к нему добавляется ссылка на новую запись). При блокировке индекса новая запись вставлена быть не может
- блокировки намерений (intent lock)
	- позволяют уменьшить время выполнения транзакций
	- для обычных блокировок - объекты блокировки записи, для блокировок намерений объект блокировки - вся таблица
		- либо на всю таблицу S, либо на всю таблицу X
		- если S, то во всю таблицу нельзя вставить ни одну строчку
		- если X, то никакая другая транзакция не сможет с этой таблицей ничего сделать
	- когда транзакция работает с отдельными записями таблицы, кроме блокировок этих записей, транзакция ставит дополнительные блокировки на таблицу
		- IS - какие-то строки таблицы заблокированы (на них S), значит на всю таблицу ставится IS
		- если на какие-то строки таблицы поставлено X, то на всю таблицу ставится IX блокировка
		- SIX - если какая-то транзакция модифицирует отдельные строки таблицы (на них поставлена X) и эта же транзакция читает всю таблицу и ставит на всю таблицу блокировку S, то есть если
			- X  на запись
			- S на всю таблицу
	- сосуществование
		- X монопольная, может существовать только в гордом одиночестве
		- SIX - может сосуществовать, если другая транзакция ставит на эту таблицу IS блокировку - другая транзакция в принципе может читать из таблицы те строки, на которые поставлена S блокировка.
		- S
		- IX
		- IS - самая слабая - когда просто читает из таблицы отдельные строки

при рассмотрении кучи  параллельных транзакций рассматривается **сериализация** -- способность к их упорядочиванию при условии, что результирующее состояние БД будет таким же, как и при параллельном выполнении команд.
- при последовательном графике все транзакции выполняются последовательно
	- по окончании работы всех транзакции БД в согласованном состоянии
	- никаких угроз нет
	- если произвольный чередующийся график запуска эквивалентен какому-то последовательному, то говорят, что он **сериализуем**
		- тогда есть какая-то гарантия что в конце БД будет в согласованном состоянии
- при чередующемся графике нельзя понять, будет ли БД согласована или нет в конце
	- если во время выполнения одной транзакции параллельно выполняются другие транзакции которые могут изменять данные говорить о достоверном состоянии БД в конце выполнения транзакций не приходится
	- хз что ждать в конце
- для параллельного выполнения транзакций есть стандарт SQL 92 который определяет будет ли график сериализуемым или нет
	- уровень 0 запрещает загрязнение данных
	- уровень 1 запрещение грязного чтения
	- и тд
- для любой субд можно проверить все эти ситуации, сделав двух клиентов рабоающих с одной БД
	- есть предложения SQL которые позволяют поставить ограничения на транзакции

### Безопасность и надежность
- вопросы надежности
	- восстановление после сбоев
		- сбой может произойти внутри транзакции, тогда БД потенциально может оказаться в несогласованном состоянии
		- после устранения сбоев надо предпринять усилия, чтобы восстановить консистентность БД
		- проблема, решение которой требует большого времени: мало восстановить согласованное состояние, но при этом мб утеряны результаты работы других транзакций
		- между t0 и t2 выполнялось возможно много транзакций, каждая из которых переводила БД в согласованное состояние
			- но если между t0 и t2 был сбой, то в t1 БД мб в несогласованном состоянии (сбой во время выполнения транзакции)
	- типы сбоев
		- программные (процедуры и тд)
		- мягкие (нарушение работы СУБД)
			- когда в системе выполняются параллельные транзакции для восстановления корректного состояния БД используются контрольные точки
			- в контрольной точке содержатся текущее состояние БД (возможно не целостное) и инфа о выполняющихся  вданный момент времени транзакциях
			- например в t1 будет инфа о выполняющихся Тр2 и Тр3 + результат работы Тр1
			- если в t2 произошел сбой, то результаты Тр2 и Тр4 в контрольной точке не отражены
				- нужно результат работы Тр2 и Тр4 сохранить, потому что эти трназакции уже завершились
				- Тр3 и Тр5 не надо, потому что они ещё не завершились
			- в t1 обнаруживаются транзакции, которые выполнялись в данный момент времени (поиск по id транзакции)
				- дальше читается журнал регистрации
				- если для транзакции находится запись, что транзакция завершилась, то начиная с контрольной точки, все действия транзакции выполняются повторно
				- для Тр3 поскольку к моменту сбоя не завершилась, то для неё никакие изменения зафиксированы не будут. Поэтому для таких транзакций отменяются дейтсвия, которые они успели выполнить до создания контрольной точки
				- Тр4 началась после контрольной точки и завершилась до сбоя, поэтому она не отражена в контрольной точке. Эта транзакция никак не обрабатывается, как будто она ничего не делала
					- Но так как она завершилась к моменту сбоя **и зафиксирована в журнале**, то она будет выполнена заново
				- Тр5 к моменту сбоя не завершилась, в КТ её тоже нет, поэтому с ней тоже ничего не делается
				- для тех транзакций, которые выполнялись в момент создания КТ (в зависимости от того, завершилась ли она в момент сбоя или нет) они либо заново выполняются, либо откатываются
		- жесткие (железо, разрушение носителя информации)
			- нарушается целостность самого носителя информации, у нас уже нет БД
			- периодически создаются архивы БД, между ними используются файлы журнала
			- для восстановления находится последний архив БД и с него выполняются операции из журнала
	- журнал регистрации
		- для восстановления БД после сбоев
		- все действия которые выполняются транзакциями еще фиксируются в лог файлах
		- при восстановлении используются записи в логах
		- журнал регистрации находится в ОП, если сбой произошел до того, как он был выгружен на диск, восстановленное состояние будет не целым
		- в ОП находятся два типа информации
			- изменяемые в транзакциях таблицы
			- журнал
			- чтобы восстановить целостное состояние БД надо чтобы сам журнал был в согласованном состоянии
		- как обеспечить согласованное состояние журнала
			- используется протокол WAL
			- все изменения сначала происходят в буферах ОП и потом уже выгружаются в диск
			- поэтому сначала надо вытолкнуть во внешнюю память лог, а потом уже таблицу
		- что хранить в журнале
			- хранится информация о каждой транзакции, которая выполняется в системе
			- во внимание принимаются те, которые изменяют таблицы
			- для каждой транзакции (у каждой транзакции есть уникальный id) которая что-то меняет, в журнале хранится список элементов:
				- начало транзакции
				- сведения, которые приводят к изменению состояния БД
					- если транзакция читает что-то, то её действия не фиксируются в журнале
					- по записи на каждое изменение
					- первая часть - состояние до изменения
					- вторая часть - что получилось после изменения
					- записи объединяются в двухсвязный список
				- конец транзакции
		- если возникают сбои (например вызов rollback)
			- то что rollback выполняется в процедуре и определяет программный сбой - например при проверке корректности выполнения операции
			- список действий транзакции начинает выполняться в обратном порядке
- вопросы безопасности
	- аутентификация
		- при начале работы в системе надо подтвердить себя
	- контроль доступа
		- в зависимости от полномочий пользователей можно сделать ридонли/разрешить что-то менять в бд etc


# 2. Распределенные системы

Так как на каждом узле распределенной системы есть своя БД, есть вероятность, что данные одновременно на двух разных узлах. Тогда изменения в одном узле должны быть растираживаны на другой узел

Если в сеть объединены машины с разной архитектурой и системой команд, как на них будут выполняться операции? Это проблема неоднородных систем. При этом данные на разных машинах могут размещаться по-разному => может получиться какая-то фигня

## Проблемы 
### Проблемы сетевого взаимодействия

Клиент и сервер дополняются сетевыми компонентами СУБД (Client Net, Server Net). Сервер один, а клиентов много. Поэтому сервер должен понимать все особенности связями со всеми клиентами.

Отсюда требования независимости от
- сетевого ПО и протоколов
- железа
- СУБД
	- не очень актуально, потому что все реляционные СУБД и так используют SQL
- и автоматическая трансляция кодов в разных форматах

### Проблемы доступа к данным

Прозрачность
- расположения
	- на каждом узле сети своя часть БД
	- в процессе работы данные между узлами могут перемещаться - оно не должно требовать изменения программ, которые работали с этими данными
- фрагментации
	- если таблица гигантская, то её часто разбивают на фрагменты, которые будут храниться на разных узлах

### Проблемы распределенных СУБД

Чтобы получить результат, нужно инициировать запрос на разных узлах сети и дождаться выполнения всех этих запросов.

Если транзакция работает с данными на разных узлах сети, то сама транзакция становится распределенной.
- если часть транзакции, совершенная с данными на части узлов, завершается rollback, то надо откатить все остальные части транзакции на других узлах

Все объекты в БД хранятся в системном каталоге который содержит имя и расположение объекта. Вопрос как это делать в распределенных системах

системный каталог
- единый централизованный 
	- хранится инфа обо всех узлах и объектах сразу
	- это плохо, единая точка отказа
- реплицированный
	- копии каталога хранятся на каждом узле сети
- локальный
	- на каждом узле не полная копия а его часть
- 1 + 3

системное имя объекта
- кто создал объект (автор)
- где размещался объект при создании
